/*
 * This source file was generated by the Gradle 'init' task
 */
package com.xingpeds.kross

import com.xingpeds.kross.parser.BuiltinCommand
import com.xingpeds.kross.parser.Executor
import com.xingpeds.kross.parser.Lexer
import com.xingpeds.kross.parser.Parser
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.io.File


@Serializable
data class Environment(val variables: Map<String, String>)
class ShellState(initialDirectory: File = File(System.getProperty("user.dir"))) {
    private val _currentDirectory = MutableStateFlow(initialDirectory)
    val currentDirectory: StateFlow<File> = _currentDirectory

    fun changeDirectory(newPath: String): Boolean {
        val newDir = File(newPath)
        return if (newDir.exists() && newDir.isDirectory) {
            _currentDirectory.value = newDir
            true
        } else {
            false
        }
    }
}


fun main() = runBlocking {
    val environment = Environment(System.getenv())
    val initCWD = File(System.getProperty("user.dir"))
    val cwd: MutableStateFlow<File> = MutableStateFlow(initCWD)
    val env = System.getenv()
    val json = Json { prettyPrint = true }.encodeToString(env)
    val cd: BuiltinCommand = { args ->
        // lets assume we get one arg and that is the path to cd to
        val arg = args.firstOrNull()
        if (arg != null) {
            // lets assume its relative for now
            val new = File(cwd.value, arg)
            if (new.exists() && new.isDirectory) {
                cwd.emit(new)
            }
        } else {
            //cd to home directory
            val home = File(System.getProperty("user.home"))
            cwd.emit(home)

        }
        0

    }
    val builtinCommands = mapOf("cd" to cd)
    File("env.json").writeText(json)

    generateSequence {
        print("input ")
        readLine()
    }.filterNotNull()
        .filter { it.isNotBlank() }
        .takeWhile { it != "exit" }
        .forEach {

            try {

                val lexer = Lexer(it)
                val parser = Parser()
                val ast = parser.parse(lexer.tokens())
                val executor = Executor(cwd, builtinCommands)
                executor.execute(ast, env = System.getenv())
            } catch (e: Exception) {
                println("failed to run command: ${e.message}")
            }
        }
}
