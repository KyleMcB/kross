/*
 * This source file was generated by the Gradle 'init' task
 */
package com.xingpeds.kross

import com.github.ajalt.mordant.terminal.Terminal
import com.xingpeds.kross.parser.BuiltinCommand
import com.xingpeds.kross.parser.Executor
import com.xingpeds.kross.parser.Lexer
import com.xingpeds.kross.parser.Parser
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.io.File


fun main() = runBlocking {
    val initCWD = File(System.getProperty("user.dir"))
    val cwd: MutableStateFlow<File> = MutableStateFlow(initCWD)
    val env = mutableMapOf<String, String>()
    env.putAll(System.getenv())
    val json = Json { prettyPrint = true }.encodeToString(env)
    val terminal = Terminal()
    val set: BuiltinCommand = { args ->
        if (args.size == 2) {
            env[args[0]] = args[1]
        } else {
            throw Exception("expected two arguments.")
        }
        0
    }
    val cd: BuiltinCommand = { args ->
        // lets assume we get one arg and that is the path to cd to
        val arg = args.firstOrNull()
        if (arg != null) {
            // lets assume its relative for now
            val new = File(cwd.value, arg)
            if (new.exists() && new.isDirectory) {
                cwd.emit(new)
            }
        } else {
            //cd to home directory
            val home = File(System.getProperty("user.home"))
            cwd.emit(home)

        }
        0

    }
    val builtinCommands = mapOf("cd" to cd, "set" to set)
    File("env.json").writeText(json)

    generateSequence {
        print("input ")
        terminal.readLineOrNull(false)
    }
        .filterNotNull()
        .filter { it.isNotBlank() }
        .takeWhile { it != "exit" }
        .forEach {

            try {

                val lexer = Lexer(it)
                val parser = Parser()
                val ast = parser.parse(lexer.tokens())
                val executor = Executor(cwd, builtinCommands)
                executor.execute(ast, env = env)
            } catch (e: Exception) {
                println("failed to run command: ${e.message}")
            }
        }
}
