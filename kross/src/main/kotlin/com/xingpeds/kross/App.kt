/*
 * This source file was generated by the Gradle 'init' task
 */
package com.xingpeds.kross

import com.xingpeds.kross.builtins.BuiltInExecutable
import com.xingpeds.kross.executable.Executable
import com.xingpeds.kross.executable.JavaOSProcess
import com.xingpeds.kross.executableLua.LuaExecutable
import com.xingpeds.kross.luaScripting.Lua
import com.xingpeds.kross.luaScripting.LuaEngine
import com.xingpeds.kross.luaScripting.executeFile
import com.xingpeds.kross.luaScripting.key
import com.xingpeds.kross.parser.Executor
import com.xingpeds.kross.parser.Lexer
import com.xingpeds.kross.parser.Parser
import com.xingpeds.kross.state.Builtin
import com.xingpeds.kross.state.ShellState
import com.xingpeds.kross.state.ShellStateObject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.runBlocking
import org.jline.keymap.KeyMap.alt
import org.jline.keymap.KeyMap.ctrl
import org.jline.reader.LineReader
import org.jline.reader.LineReaderBuilder
import org.jline.reader.Reference
import org.jline.reader.Widget
import org.jline.reader.impl.history.DefaultHistory
import org.jline.terminal.Terminal
import org.jline.terminal.TerminalBuilder
import org.jline.widget.AutosuggestionWidgets
import org.jline.widget.Widgets
import org.luaj.vm2.LuaFunction
import org.luaj.vm2.LuaValue
import java.io.File


fun LuaValue.funcOrNull(): LuaFunction? = try {
    this.checkfunction()
} catch (e: Exception) {
    null
}

fun LuaValue.toNullable(): LuaValue? {
    return if (this.isnil()) null else this
}

class MyWidgets(reader: LineReader) : Widgets(reader) {

    init {
        // Add the custom widget
        addWidget("test-widget", Widget { testWidget() })

        // Bind Ctrl-X to the widget
        val keyMap = reader.keyMaps[LineReader.MAIN]
//        println("Before Binding: ${keyMap?.boundKeys?.keys?.joinToString("")}") // Debug keymap before binding

        keyMap?.bind(Reference("test-widget"), alt(ctrl('X')))
//        println("Before Binding: ${keyMap?.boundKeys?.keys?.joinToString("")}") // Debug keymap before binding
    }

    fun testWidget(): Boolean {
        println("testWidget called!")
        return try {
            val name = buffer().toString().split("\\s+".toRegex())[0]
            println("Buffer content: $name")
            reader.callWidget(name)
            true
        } catch (e: Exception) {
            e.printStackTrace() // Print exception for debugging
            false
        }
    }
}

fun main() = runBlocking {
    val scope = CoroutineScope(Dispatchers.Default)
    val state: ShellState = ShellStateObject
    val lua: Lua = LuaEngine
    val initFile = initFile()
    lua.executeFile(initFile)
    val history = DefaultHistory()
    val terminal: Terminal = TerminalBuilder.builder().system(true).build()
    // Create a line reader
    val commandCompleter = CommandCompleter(lua)
    val cwdCompleter = CurrentDirectoryCompleter(ShellStateObject.currentDirectory, scope)
    val shellCompleter = ShellCompleter(commandCompleter, cwdCompleter)
    val lineReader: LineReader = LineReaderBuilder.builder()
        .completer(shellCompleter)
        .terminal(terminal)
        .history(history)
        .build()
    val bla = MyWidgets(lineReader)
    val autosuggestionWidgets = AutosuggestionWidgets(lineReader)
//    lineReader.getKeyMaps().bind(Reference("clear"), "\u0003");
    val keyMap = lineReader.keyMaps[LineReader.MAIN] ?: throw Exception("DEATH")

//    println(keyMap.boundKeys.keys.joinToString(separator = ","))
    keyMap.boundKeys
    // Bind Ctrl-C (ASCII 3) to a custom action "print-hello"
    keyMap.bind(Reference("print-hello"), "\u0003") // "\u0003" is Ctrl-C

    // Define the behavior for "print-hello"
//    lineReader.setVariable(LineReader.BINDINGS, mapOf("print-hello" to Runnable {
//        println("Hello, World!")
//    }))
//    println(lineReader.keyMaps.keys.joinToString("\n"))

// Enable autosuggestions
    autosuggestionWidgets.enable()
    lineReader.variable(LineReader.HISTORY_FILE, getHistoryFile())
    while (true) {
        try {
            // Prompt the user and read input
            val username = System.getProperty("user.name")
            val userhome: String = System.getProperty("user.home")
            val cwd: String = ShellStateObject.currentDirectory.value.absolutePath.replace(userhome, "~")
            var prompt = "$username $cwd> "
            val promptfunc = LuaEngine.global.key("kross")?.key("handles")?.key("prompt")?.funcOrNull()
            if (promptfunc != null) {
                prompt = promptfunc.call().tojstring()
            }
            val line = lineReader.readLine(prompt).trim()
            if (line.isBlank()) continue

            // Check for exit condition
            if (line.equals("exit", ignoreCase = true)) {
                break
            }

            try {

                val lexer = Lexer(line)
                val parser = Parser()
                val ast = parser.parse(lexer.tokens())
                val makeExecutable: suspend (name: String) -> Executable = { name ->
                    if (LuaEngine.userFuncExists(name)) {
                        LuaExecutable()
                    } else if (Builtin.builtinFuns.containsKey(name)) {
                        BuiltInExecutable(Builtin.builtinFuns[name]!!)
                    } else {
                        JavaOSProcess()
                    }
                }
                val executor = Executor(cwd = state.currentDirectory, makeExecutable = makeExecutable)
                executor.execute(ast)
            } catch (e: Exception) {
                println("failed to run command: ${e.message}")
// this should be in debug mode only
                println(e.stackTraceToString())
            }
            // Print back what the user entered (or evaluate if needed)

        } catch (e: Exception) {
            terminal.writer().println("Error: ${e.message}")
        }
    }
    scope.cancel()
}

fun getHistoryFile(): File {
    // Get the path to the history file
    val historyFilePath = "${System.getProperty("user.home")}/.config/kross/data/history"
    val historyFile = File(historyFilePath)

    // Ensure the parent directories and the file exist
    if (!historyFile.exists()) {
        historyFile.parentFile.mkdirs() // Create parent directories if they do not exist
        historyFile.createNewFile()    // Create the file if it does not exist
    }

    return historyFile
}