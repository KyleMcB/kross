/*
 * This source file was generated by the Gradle 'init' task
 */
package com.xingpeds.kross

import com.xingpeds.kross.builtins.BuiltInExecutable
import com.xingpeds.kross.executable.Executable
import com.xingpeds.kross.executable.JavaOSProcess
import com.xingpeds.kross.executableLua.LuaExecutable
import com.xingpeds.kross.luaScripting.Lua
import com.xingpeds.kross.luaScripting.LuaEngine
import com.xingpeds.kross.luaScripting.executeFile
import com.xingpeds.kross.luaScripting.key
import com.xingpeds.kross.parser.Executor
import com.xingpeds.kross.parser.Lexer
import com.xingpeds.kross.parser.Parser
import com.xingpeds.kross.state.Builtin
import com.xingpeds.kross.state.ShellState
import com.xingpeds.kross.state.ShellStateObject
import kotlinx.coroutines.runBlocking
import org.jline.builtins.Completers.DirectoriesCompleter
import org.jline.reader.LineReader
import org.jline.reader.LineReaderBuilder
import org.jline.reader.impl.history.DefaultHistory
import org.jline.terminal.Terminal
import org.jline.terminal.TerminalBuilder
import org.luaj.vm2.LuaFunction
import org.luaj.vm2.LuaValue
import java.io.File

fun LuaValue.funcOrNull(): LuaFunction? = try {
    this.checkfunction()
} catch (e: Exception) {
    null
}

fun LuaValue.toNullable(): LuaValue? {
    return if (this.isnil()) null else this
}


fun main() = runBlocking {
    val state: ShellState = ShellStateObject
    val lua: Lua = LuaEngine
    val initFile = initFile()
    lua.executeFile(initFile)
    val history = DefaultHistory()
    val terminal: Terminal = TerminalBuilder.builder().system(true).build()

    // Create a line reader
    val lineReader: LineReader = LineReaderBuilder.builder()
        .completer(DirectoriesCompleter(state.currentDirectory.value))
        .terminal(terminal)
        .history(history)
        .build()
    lineReader.variable(LineReader.HISTORY_FILE, getHistoryFile())
    while (true) {
        try {
            // Prompt the user and read input
            val username = System.getProperty("user.name")
            val userhome: String = System.getProperty("user.home")
            val cwd: String = ShellStateObject.currentDirectory.value.absolutePath.replace(userhome, "~")
            var prompt = "$username $cwd> "
            val promptfunc = LuaEngine.global.key("kross")?.key("handles")?.key("prompt")?.funcOrNull()
            if (promptfunc != null) {
                prompt = promptfunc.call().tojstring()
            }
            val line = lineReader.readLine(prompt).trim()
            if (line.isBlank()) continue

            // Check for exit condition
            if (line.equals("exit", ignoreCase = true)) {
                break
            }

            try {

                val lexer = Lexer(line)
                val parser = Parser()
                val ast = parser.parse(lexer.tokens())
                val makeExecutable: suspend (name: String) -> Executable = { name ->
                    if (LuaEngine.userFuncExists(name)) {
                        LuaExecutable()
                    } else if (Builtin.builtinFuns.containsKey(name)) {
                        BuiltInExecutable(Builtin.builtinFuns[name]!!)
                    } else {
                        JavaOSProcess()
                    }
                }
                val executor = Executor(cwd = state.currentDirectory, makeExecutable = makeExecutable)
                executor.execute(ast)
            } catch (e: Exception) {
                println("failed to run command: ${e.message}")
// this should be in debug mode only
                println(e.stackTraceToString())
            }
            // Print back what the user entered (or evaluate if needed)

        } catch (e: Exception) {
            terminal.writer().println("Error: ${e.message}")
        }
    }
}

fun getHistoryFile(): File {
    // Get the path to the history file
    val historyFilePath = "${System.getProperty("user.home")}/.config/kross/data/history"
    val historyFile = File(historyFilePath)

    // Ensure the parent directories and the file exist
    if (!historyFile.exists()) {
        historyFile.parentFile.mkdirs() // Create parent directories if they do not exist
        historyFile.createNewFile()    // Create the file if it does not exist
    }

    return historyFile
}